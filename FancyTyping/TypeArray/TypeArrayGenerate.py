# Author: Jesse Russell
# Summary: Generates the struct definitions for the TypeArray datatype, up to n type parameters.

# Parameters:
FILE_NAME = "TypeArray.cs"
NAMESPACE = "JesseRussell.FancyTyping"
STRUCT_NAME = "TypeArray"
TYPE_PARAMETER_COUNT = 64
#


# Constants:
INDENT = "    "
#


# Returns string representation of the parameter: enumerable, delimited my the delim parameter.
def to_delim_string(enumerable, delim=", "):
    s = ""
    first = True
    for item in enumerable:
        if not first:
            s = s + delim

        s = s + str(item)

        first = False

    return s


# Open output file.
output = open(FILE_NAME, "w")

# #=========================#
# | Begin code generation:  |
# | ----------------------  |
# #=========================#

# Note.
output.write("//This code was generated by TypeArrayGenerate.py\n")

# Using directives:
output.write("using System;\n" +
             "using System.Collections;\n" +
             "using System.Collections.Generic;\n")
#

# Namespace declaration.
output.write("namespace " + NAMESPACE + "\n{\n")

types = []
# Main loop...
for i in range(0, TYPE_PARAMETER_COUNT):
    # Increment the last type parameter.
    types.append("T" + str(i))

    # Just to make things easier:
        # FullName...
    def full_name():
        return STRUCT_NAME + "<" + to_delim_string(types) + ">"

    FULL_NAME = full_name()

        # tn...
    def t(j):
        return "t" + str(j)

        # Tn...
    def T(j):
        return "T" + str(j)
    #

    # Struct declaration:
    output.write(INDENT + "public struct " + FULL_NAME + " : ITypeArray\n" +
                 INDENT + "{\n")
    #

    # GetEnumerator:
    output.write(INDENT * 2 + "public IEnumerator<Type> GetEnumerator()\n"+
                 INDENT * 2 + "{\n")
    first = True
    for j in range(0, i + 1):
        if j % 3 == 0 and not first:
            output.write("\n" + INDENT * 3)

        if first:
            output.write(INDENT * 3)

        output.write("yield return typeof(" + T(j) + ");")
        first = False

    output.write("\n")

    output.write(INDENT * 2 + "}\n")

    output.write(INDENT * 2 + "IEnumerator IEnumerable.GetEnumerator() => this.GetEnumerator();\n")
    #

    # Indexing[]:
    output.write(INDENT * 2 + "public Type this[int i]\n"+
                 INDENT * 2 + "{\n"+
                 INDENT * 3 + "get\n"+
                 INDENT * 3 + "{\n"+
                 INDENT * 4 + "switch (i)\n" +
                 INDENT * 4 + "{\n")

    first = True
    for j in range(0, i + 1):
        if j % 3 == 0 and not first:
            output.write("\n" + INDENT * 5)

        if first:
            output.write(INDENT * 5)

        output.write("case " + str(j) + ": return typeof(" + T(j) + ");")
        
        first = False
    output.write("\n")

    output.write((INDENT * 5 + "default: throw new IndexOutOfRangeException();\n"+
                  INDENT * 4 + "}\n"+
                  INDENT * 3 + "}\n"+
                  INDENT * 2 + "}\n"))
    #

    # Length.
    output.write(INDENT * 2 + "public int Length => " + str(i + 1) + ";\n")

    # Casts:
    output.write(INDENT * 2 + "public static implicit operator Type[](" + FULL_NAME + " ta) => new Type[] { ")
    first = True;
    for j in range(0, i + 1):
        if not first:
            output.write(", ")
        output.write("typeof(" + T(j) + ")")
        first = False;
    output.write(" };\n")
    #

    # Close struct.
    output.write("    }\n")

# Close namespace.
output.write("}")

# *Code Generation finished.

# Close output file.
output.close()
